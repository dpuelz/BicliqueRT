% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/functions.R
\name{clique_test}
\alias{clique_test}
\title{The main randomization test function.}
\usage{
clique_test(Y, Z, Z_a, Z_b, Zobs_id, decom = "bimax", ...)
}
\arguments{
\item{Y}{The observed outcome vector.}

\item{Z}{A binary matrix of dimension (number of units x number of randomizations, i.e. assignments.) storing the assignment vectors. Please see example.}

\item{Z_a}{A binary matrix with dimension (number of units x number of randomizations, i.e. assignments.)  Row i, column j of the matrix corresponds to whether a unit i is exposed to \code{a} under assignment j. Please see example.}

\item{Z_b}{A binary matrix with (number of units x number of randomizations, i.e. assignments.)  Row i, column j of the matrix corresponds to whether a unit i is exposed to \code{b} under assignment j. Please see example.}

\item{Zobs_id}{The index location of the observed assignment vector in \code{Z}, \code{Z_a}, and \code{Z_b}.}

\item{decom}{The algorithm used to calculate the biclique decomposition. Currently supported algorithms
are "bimax" and "greedy".}

\item{...}{Other stuff ...}
}
\value{
A list of items summarizing the randomization test. If for some focal assignments
in the a biclique that contains \code{Zobs}, exposures for each unit are the same, it will
contain an error message, and the test decision will be \code{NA}.
}
\description{
The main randomization test function.
}
\examples{
# Spatial interference
# generated network - 3 clusters of 2D Gaussians
# loads in the 500x500 matrix Dmat
# Dmat just encodes all pairwise Euclidean distances between network nodes, and
# this is used to define the spillover hypothesis below.
library(CliqueRT)
set.seed(1)
thenetwork = out_example_network(500)
D = thenetwork$D

# simulation parameters
num_randomizations = 5000
radius = 0.01

# First, construct Z, Z_a, Z_b.
# Here, exposure a is an untreated within radius of a treated unit, and exposure b
# is an untreated unit at least radius distance away from all treated units.
# Experimental design is Bernoulli with prob=0.2.
# a_threshold is a scalar denoting the threshold that triggers an exposure to a.  If exposure a
# is simply binary, i.e. whether or not unit j is exposed to a, then this value should be set to 1.
# b_threshold is a scalar denoting the threshold that triggers an exposure to b.  If exposure b
# is simply binary, i.e. whether or not unit j is exposed to b, then this value should be set to 1.
Z = out_Z(pi=rep(0.2,dim(D)[1]),num_randomizations)
D_a = D_b = sparsify((D<radius))
a_threshold = b_threshold = 1

Z_a = Z_b = D_a\%*\%Z
Z_a = sparsify((Z_a>=a_threshold))
Z_b = sparsify((Z_b<b_threshold))

# simulating an outcome vector
Y_a = rnorm(dim(Z)[1])
Y_b = Y_a + 0.2
Y = out_Yobs(Z_a[,1],Z_b[,1],Y_a,Y_b)

# run the test using Bimax to decompose the null-exposure graph
CRT = clique_test(Y, Z, Z_a, Z_b, Zobs_id=1, decom='bimax', minr=15, minc=15)

# alternatively, we can use a greedy algorithm to do decomposition by specifying decom
CRT = clique_test(Y, Z, Z_a, Z_b, Zobs_id=1, decom='greedy', minass=15)

# Clustered interference
# simulation parameters
N = 2000
K = 500
Zobs_id = 1

# generate clustered structure
library(Matrix)
library(biclust)
set.seed(1)
Zprime_mat = out_Zprime(N, K, numrand=1000)
Z = Zprime_mat==2
Z_a = Zprime_mat==1
Z_b = Zprime_mat==0

# simulate an outcome vector
simdat = out_bassefeller(N, K, Zprime_mat[, Zobs_id],tau_main = 0.4)
Yobs = simdat$Yobs

# run the test using Bimax
CRT = clique_test(Yobs, Z, Z_a, Z_b, Zobs_id, decom='bimax', minr=20, minc=20)
# again, we can use the greedy algorithm as follows:
CRT = clique_test(Yobs, Z, Z_a, Z_b, Zobs_id, decom='greedy', minass=20)

}
